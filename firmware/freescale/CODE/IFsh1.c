/* ###################################################################
**     This component module is generated by Processor Expert. Do not modify it.
**     Filename    : IFsh1.c
**     Project     : ProcessorExpert
**     Processor   : MC9S08JS16CWJ
**     Component   : IntFLASH
**     Version     : Component 02.409, Driver 01.31, CPU db: 3.00.017
**     Compiler    : CodeWarrior HCS08 C Compiler
**     Date/Time   : 2015-10-19, 15:53, # CodeGen: 62
**     Abstract    :
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
**     Settings    :
**         Total FLASH memory size       : 0x4000 bytes
**         Number of FLASH memory blocks : 1
**         Flash block
**           Address range               : 0xC000-0xFFFF
**           Size                        : 0x4000
**           Sector size                 : 0x0200
**         Write method                  : Destructive write (with erase)
**         Wait in RAM                   : yes
**         Virtual page                  : Disabled
**         CPU clock/speed selection
**           FLASH clock                 : 187.5 kHz
**           High speed mode             : This component enabled
**     Contents    :
**         SetByteFlash  - byte IFsh1_SetByteFlash(IFsh1_TAddress Addr, byte Data);
**         SetWordFlash  - byte IFsh1_SetWordFlash(IFsh1_TAddress Addr, word Data);
**         SetLongFlash  - byte IFsh1_SetLongFlash(IFsh1_TAddress Addr, dword Data);
**         GetLongFlash  - byte IFsh1_GetLongFlash(IFsh1_TAddress Addr, dword *Data);
**         SetBlockFlash - byte IFsh1_SetBlockFlash(IFsh1_TDataAddress Source, IFsh1_TAddress Dest, word...
**         GetBlockFlash - byte IFsh1_GetBlockFlash(IFsh1_TAddress Source, IFsh1_TDataAddress Dest, word...
**         DataPtr2Addr  - IFsh1_TAddress IFsh1_DataPtr2Addr(void* Addr);
**         FuncPtr2Addr  - IFsh1_TAddress IFsh1_FuncPtr2Addr(void(*Addr)());
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file IFsh1.c
** @version 01.31
** @brief
**         This component "IntFLASH" implements an access to internal FLASH.
**         The component support reading/writing data into FLASH, erasing of
**         selected sector.
**         The component supports events if the write interrupt is supported.
**         The component supports following modes of write operations:
**           - Write - writing without any test.
**           - Destructive write - sector is erased if necessary.
**           - Safe write - user event is invoked to save and resore data
**                          from the current sector.
**         The component requires on-chip FLASH memory (not used/allocated by
**         other components).
*/         
/*!
**  @addtogroup IFsh1_module IFsh1 module documentation
**  @{
*/         

/* MODULE IFsh1. */

#include "IFsh1.h"


/*lint -save  -e923 Disable MISRA rule (11.3) checking. */
/* Function prototypes, that are located in RAM */
typedef void (*PFnCmdInRam)(byte Comand_);

/* Internal method prototypes */
/*
** ===================================================================
**     Method      :  FnCmdInRam_ (component IntFLASH)
**
**     Description :
**         This code burns one byte. It is copied to the RAM.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void FnCmdInRam_(byte Comand_);

/*
** ===================================================================
**     Method      :  LaunchCmdAndTestError (component IntFLASH)
**
**     Description :
**         This method executes flash command and tests result of the 
**         operation.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte IFsh1_LaunchCmdAndTestError(byte Command_, IFsh1_TAddress Addr_, byte Value_);


#define FCMD_BLANK_CHECK    0x05U      /* Flash command code */
#define FCMD_PROGRAM        0x20U      /* Flash command code */
#define FCMD_BURST_PROGRAM  0x25U      /* Flash command code */
#define FCMD_PAGE_ERASE     0x40U      /* Flash command code */
#define FCMD_MASS_ERASE     0x41U      /* Flash command code */
#define BM_FLASH_ERR_MASK   0x30U      /* Bit mask to get FLASH error bits from FSTAT */
#define FLASH_PAGE_SIZE     0x0200U    /* Size of flash page */
#define BM_FLASH_INDEX      (FLASH_PAGE_SIZE - 0x01U) /* Value to get index part of address */
#define BM_FLASH_PAGE       (~(word)(BM_FLASH_INDEX)) /* Value to get index part of address */

typedef struct {
  byte code[0x28];                     /* Structure required to copy code to ram memory */
  /* Size of this structure needs to be at least (but best) the size of the FnCmdInRam_ */
} TFnCmdInRamStruct;



#pragma MESSAGE DISABLE C1805    /* Disable message: Non standard conversion used */

/*
** ===================================================================
**     Method      :  IFsh1_FnCmdInRam_ (component IntFLASH)
**
**     Description :
**         This code burns one byte. It is copied to the RAM.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void FnCmdInRam_(byte Comand_)
{
  FCMD = Comand_;                      /* Initiate command */
  FSTAT = 0x80U;                       /* Launch the command */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm nop;                             /* Wait at least four bus cycles before checking FSTAT */
  asm nop;
  asm nop;
  asm nop;
  /*lint -restore Enable MISRA rule (1.1) checking. */
  if ((FSTAT & BM_FLASH_ERR_MASK) == 0U) { /* If no protection violation or access error detected */
    while (FSTAT_FCCF == 0U) {}        /* Wait for command completion */
  }
  return;
}

/*
** ===================================================================
**     Method      :  IFsh1_LaunchCmdAndTestError (component IntFLASH)
**
**     Description :
**         This method executes flash command and tests result of the 
**         operation.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte IFsh1_LaunchCmdAndTestError(byte Command_, IFsh1_TAddress Addr_, byte Value_)
{
  /*lint -save  -e740 -e931 -e926 -e927 -e928 -e929 Disable MISRA rule (1.2,11.4) checking. */
  TFnCmdInRamStruct FnCmdInRam = *(TFnCmdInRamStruct *)(FnCmdInRam_);
  /*lint -restore Enable MISRA rule (1.2,11.4) checking. */

  SaveStatusReg();                     /* Save the PS register */
  FSTAT = 0x00U;                       /* Init. flash engine */
  if ((FSTAT & BM_FLASH_ERR_MASK) != 0U) { /* Protection violation or access error? */
    FSTAT = BM_FLASH_ERR_MASK;         /* Clear FPVIOL & FACERR flag */
  }
  *(volatile byte *) (Addr_) = Value_; /* Write data to the flash memory */
  /*lint -save  -e740 -e931 -e926 -e927 -e928 -e929 Disable MISRA rule (1.2,11.4) checking. */
  ((PFnCmdInRam)&FnCmdInRam)(Command_); /* Call code in RAM */
  /*lint -restore Enable MISRA rule (1.2,11.4) checking. */
  RestoreStatusReg();                  /* Restore the PS register */
  if ((FSTAT & BM_FLASH_ERR_MASK) != 0U) { /* Error detected? */
    if ((FSTAT_FPVIOL) != 0U) {        /* Protect violation? */
      return ERR_PROTECT;              /* Return error code ERR_PROTECT */
    } else {
      return ERR_NOTAVAIL;             /* Return error code ERR_NOTAVAIL */
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_NonDestructiveUnsecureWrite (component IntFLASH)
**
**     Description :
**         This method performs Non-destructive unsecure write.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte IFsh1_NonDestructiveUnsecureWrite(IFsh1_TAddress src, IFsh1_TAddress dst, word size)
{
  byte tmp;                            /* Temporary read current destination value */
  /*lint -save  -e740 -e931 -e926 -e927 -e928 -e929 Disable MISRA rule (1.2,11.4) checking. */
  TFnCmdInRamStruct FnCmdInRam = *(TFnCmdInRamStruct *)(FnCmdInRam_);
  /*lint -restore Enable MISRA rule (1.2,11.4) checking. */

  if ((FSTAT_FCCF) == 0U) {            /* Is previous command completed ? */
    return ERR_BUSY;                   /* If no then error */
  }
  SaveStatusReg();                     /* Save status information and disable interrupts(if enabled) */
  FSTAT = 0x00U;                       /* Init. flash engine */
  if ((FSTAT & BM_FLASH_ERR_MASK) != 0U) { /* Protection violation or access error? */
    FSTAT = BM_FLASH_ERR_MASK;         /* Clear FPVIOL & FACERR flag */
  }
  /* Burn data into FLASH */
  while (size--) {                     /* For all written bytes do: */
    tmp = *(byte *)dst;                /* Read current byte value from FLASH */
    if (*(byte *)src != tmp) {         /* Is the src. byte equal to the dest. byte? */
      *(byte *)dst = *(byte *)src | (byte)~(byte)tmp; /* Write byte to the flash memory, do not modify zero bits */
      /*lint -save  -e740 -e931 -e926 -e927 -e928 -e929 Disable MISRA rule (1.2,11.4) checking. */
      ((PFnCmdInRam)&FnCmdInRam)(FCMD_BURST_PROGRAM); /* Call code in ram */
      /*lint -restore Enable MISRA rule (1.2,11.4) checking. */
    }
    ++dst;                             /* Increment destination pointer */
    ++src;                             /* Increment source pointer */
  } /* while size */
  RestoreStatusReg();                  /* Restore status information and interrupt state */
  if ((FSTAT & BM_FLASH_ERR_MASK) != 0U) { /* Error detected? */
    if ((FSTAT_FPVIOL) != 0U) {        /* Protect violation? */
      return ERR_PROTECT;              /* Return error code ERR_PROTECT */
    } else {
      return ERR_NOTAVAIL;             /* Return error code ERR_NOTAVAIL */
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_WriteBlock (component IntFLASH)
**
**     Description :
**         The method writes block of data to a flash memory.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte IFsh1_WriteBlock(IFsh1_TAddress src, IFsh1_TAddress dst, word size)
{
  byte res;                            /* Tmp. var. for function call result */
  IFsh1_TAddress src_tmp = src;        /* Tmp. pointer to the src. memory */
  IFsh1_TAddress dst_tmp;              /* Tmp. pointer to the dest. memory */
  IFsh1_TAddress DstEnd = dst + size;  /* Address of the first byte after the end of the dest. block */
  IFsh1_TAddress SrcEnd = src + size;  /* Address of the first byte after the end of the src. block */

  if (dst < 0xC000U) {                 /* Check address range */
    return ERR_RANGE;                  /* Address is out of FLASH memory */
  }
  if ((size > 0x4000U) || (((dst + size) - 1U) < 0xC000U)) { /* Check block size and last address of the block */
    return ERR_RANGE;                  /* Last Address is out of FLASH memory */
  }
  for (dst_tmp = dst; src_tmp < SrcEnd; dst_tmp++) { /* For all bytes in dest. block do: */
    if ((((byte)~*(byte *)dst_tmp) & *(byte *)src_tmp) != 0U) { /* Test if erase is necessary */
      res = IFsh1_LaunchCmdAndTestError((byte)FCMD_PAGE_ERASE, dst_tmp, (byte)0x00); /* Erase sector */
      if (res != ERR_OK) {             /* Sector erase error? */
        return res;                    /* Yes, return error code */
      }
      src_tmp += (~dst_tmp & BM_FLASH_INDEX); /* Increase pointer to point to src. data that should be written to the next flash sector */
      dst_tmp = ((dst_tmp + FLASH_PAGE_SIZE) & BM_FLASH_PAGE) - 1U; /* Increase pointer to point to the next flash sector */
    }
    src_tmp++;                         /* Increment src. address */
  } /* for all bytes in the block */
  res = IFsh1_NonDestructiveUnsecureWrite(src, dst, size); /* Write data */
  if (res != ERR_OK) {                 /* Write error? */
    return res;                        /* Yes, return error code */
  }
  for(;;) {                            /* Compare src. and written block */
    if ((*(byte *)src) != (*(byte *)dst)) { /* Compare source byte and written byte */
      return ERR_VALUE;                /* Source value is different from dest. value, return error */
    }
    if (--size == 0U) {
      break;                           /* Finish if compared last written byte */
    }
    /* *** */
    ++src;                             /* Next byte */
    ++dst;
  } /* for */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_SetByteFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a byte to an address in FLASH. The operation of this
**         method depends on the "Write method" property and state of
**         the flash. Please see more details on general info page of
**         the help.
**     @param
**         Addr            - Address to FLASH.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_VALUE - Read value is not equal to
**                           written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetByteFlash(IFsh1_TAddress Addr, byte Data)
{
  return IFsh1_WriteBlock((IFsh1_TAddress)&Data, Addr, 0x01U); /* Write data to the flash */
}

/*
** ===================================================================
**     Method      :  IFsh1_SetWordFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a word to an address in FLASH. The operation of this
**         method depends on the "Write method" property and state of
**         the flash. Please see more details on general info page of
**         the help.
**     @param
**         Addr            - Address to FLASH.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - Address is out of range 
**                           - ERR_VALUE - Read value is not equal to
**                           written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetWordFlash(IFsh1_TAddress Addr, word Data)
{
  return IFsh1_WriteBlock((IFsh1_TAddress)&Data, Addr, 0x02U); /* Write data to the flash */
}

/*
** ===================================================================
**     Method      :  IFsh1_SetLongFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes a long word to an address in FLASH. The operation of
**         this method depends on the "Write method" property and state
**         of the flash. Please see more details on general info page
**         of the help.
**     @param
**         Addr            - Address to FLASH.
**     @param
**         Data            - Data to write.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - The address is out of range 
**                           - ERR_VALUE - The read value is not equal
**                           to the written value 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_PROTECT - Flash is write protect
*/
/* ===================================================================*/
byte IFsh1_SetLongFlash(IFsh1_TAddress Addr, dword Data)
{
  return IFsh1_WriteBlock((IFsh1_TAddress)&Data, Addr, 0x04U); /* Write data to the flash */
}

/*
** ===================================================================
**     Method      :  IFsh1_GetLongFlash (component IntFLASH)
*/
/*!
**     @brief
**         Gets a long word from an address in FLASH.
**     @param
**         Addr            - Address to FLASH.
**     @param
**         Data            - A pointer to the returned 32-bit data.
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - The address is out of range 
**                           - ERR_BUSY - Device is busy
*/
/* ===================================================================*/
byte IFsh1_GetLongFlash(IFsh1_TAddress Addr, dword *Data)
{
  if ((Addr < 0xC000U) || (Addr > 0xFFFCU)) { /* Check address range */
    return ERR_RANGE;                  /* Block is out of FLASH memory */
  }
  *Data = *(volatile dword *)(Addr);   /* Get double word from Flash */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_SetBlockFlash (component IntFLASH)
*/
/*!
**     @brief
**         Writes data to FLASH. The operation of this method depends
**         on the "Write method" property and state of the flash.
**         Please see more details on general info page of the help.
**     @param
**         Source          - Source address of the data.
**     @param
**         Dest            - Destination address in FLASH.
**     @param
**         Count           - Count of the data fields (in the
**                           smallest addressable units).
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - The address is out of range 
**                           - ERR_BUSY - Device is busy 
**                           - ERR_SPEED - This device does not work in
**                           the active speed mode 
**                           - ERR_PROTECT - Flash is write protect 
**                           - ERR_VALUE - Read value is not equal to
**                           written value
*/
/* ===================================================================*/
byte IFsh1_SetBlockFlash(IFsh1_TDataAddress Source, IFsh1_TAddress Dest, word Count)
{
  return IFsh1_WriteBlock((IFsh1_TAddress)Source, Dest, Count); /* Write data to the flash */
}

/*
** ===================================================================
**     Method      :  IFsh1_GetBlockFlash (component IntFLASH)
*/
/*!
**     @brief
**         Reads data from FLASH.
**     @param
**         Source          - Destination address in FLASH.
**     @param
**         Dest            - Source address of the data.
**     @param
**         Count           - Count of the data fields (in the
**                           smallest addressable units).
**     @return
**                         - Error code, possible codes: 
**                           - ERR_OK - OK 
**                           - ERR_NOTAVAIL - Desired program/erase
**                           operation is not available 
**                           - ERR_RANGE - The address is out of range 
**                           - ERR_BUSY - Device is busy
*/
/* ===================================================================*/
byte IFsh1_GetBlockFlash(IFsh1_TAddress Source, IFsh1_TDataAddress Dest, word Count)
{
  if ((Source < 0xC000U) || (Source > ((0xFFFFU - Count) + 1U))) { /* Check address range */
    return ERR_RANGE;                  /* Address is out of FLASH memory */
  }
  while(Count--) {
    *Dest = *(byte *)Source;
    ++Source;
    ++Dest;
  } /* while Count */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  IFsh1_Init (component IntFLASH)
**
**     Description :
**         Description_Init - Initializes the associated peripheral(s) 
**         and the component's internal variables. The method is called 
**         automatically as a part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void IFsh1_Init(void)
{
  /* FSTAT: FCBEF=0,FCCF=0,FPVIOL=1,FACCERR=1,??=0,FBLANK=0,??=0,??=0 */
  setReg8(FSTAT, 0x30U);               /* Clear FPVIOL & FACERR flag */ 
  /* FCDIV: DIVLD=0,PRDIV8=1,DIV5=0,DIV4=0,DIV3=1,DIV2=1,DIV1=1,DIV0=1 */
  setReg8(FCDIV, 0x4FU);               /* Initialize FCDIV register */ 
}

/*
** ===================================================================
**     Method      :  IFsh1_DataPtr2Addr (component IntFLASH)
*/
/*!
**     @brief
**         This method converts data pointer to format of a component's
**         method address parameter. Generally a data pointer format is
**         different from format of a method Addr parameter.
**     @param
**         Addr            - Data pointer.
**     @return
**                         - Address in the format used in the component
**                           methods.
*/
/* ===================================================================*/
/*
IFsh1_TAddress IFsh1_DataPtr2Addr(void * Addr)

**      This method is implemented as macro. See IFsh1.h file.      **

*/

/*
** ===================================================================
**     Method      :  IFsh1_FuncPtr2Addr (component IntFLASH)
*/
/*!
**     @brief
**         This method converts function pointer to format of a
**         component's method address parameter. Generally a function
**         pointer format is different from format of a method Addr
**         parameter.
**     @param
**         Addr            - Function pointer.
**     @return
**                         - Address in the format used in the component
**                           methods.
*/
/* ===================================================================*/
/*
IFsh1_TAddress IFsh1_FuncPtr2Addr(void(*Addr)())

**      This method is implemented as macro. See IFsh1.h file.      **

*/

/*lint -restore Enable MISRA rule (11.3) checking. */
/* END IFsh1. */
/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale HCS08 series of microcontrollers.
**
** ###################################################################
*/
